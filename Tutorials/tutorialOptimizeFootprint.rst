Optimize the Memory Footprint of an Application
===============================================

This tutorial explains how a developer can analyze the footprint of an application and how he can reduce both the ROM and the RAM footprint.

Often, the developer has already started coding when he starts thinking about the footprint of his application.
Before jumping into code optimizations, it is best to list every area of improvement, and estimate for each area how much memory can be gained and how much effort it requires.
Without performing the analysis first, the developer might start working on a minor optimization which takes a lot of effort for a small gain, whereas he could be working on a major optimization allowing a faster and bigger gain.
Besides, an optimization may allow a significant gain in an application while it would not be relevant in an other application.
This is why this tutorial starts by explaining how the developer can analyze the footprint of his application, before providing guidelines that can be followed to reduce the footprint.

How to Analyze the Footprint of an Application
----------------------------------------------

This section explains the process of analyzing the footprint of a MicroEJ Application and the tools used during the analysis.

Suggested footprint analysis process:

1. Build the MicroEJ Application on device
2. Analyze ``SOAR.map`` with the :ref:`memorymapanalyzer`
3. Analyze ``SOAR.xml`` with an XML editor
4. Link the MicroEJ Application with the BSP
5. Analyze the map file generated by the third-party linker with a text editor

Footprint analysis tools:

- The :ref:`memorymapanalyzer` allows to analyze the memory consumption of different features in the RAM and ROM.
- The :ref:`heapdumper` allow to understand the contents of the Java heap and find problems such as memory leaks.
- The `Dependency Discoverer <https://forum.microej.com/t/tool-dependency-discoverer/771>`_  allows to analyze a piece of code to detect all its dependencies.

How to Analyze a SOAR.map File
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A ``SOAR.map`` file is generated after building a MicroEJ Application on device.
This file lists every embedded symbol of the application (section, Java class or method, etc.) and its size in ROM or RAM.
The ``SOAR.map`` file can be opened using the :ref:`memorymapanalyzer`.

The embedded symbols are grouped into multiple categories. For example, the ``Object`` class and its methods are in the ``LibFoundationEDC`` category.
For each symbol or each category, you can see its size in ROM (``Image Size``) and RAM (``Runtime Size``).

The linker regroups all the strings in the same section. The same applies to the static fields, the types and the class names. Each of these sections is displayed in its own category.

How to Analyze a SOAR.xml File
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A ``soar/<MainClass>.xml`` file is generated after building a MicroEJ Application on device.
This file can be opened using any XML editor.

This file contains the list of:

- every embedded method and its size (in ``selected_methods`` tag)
- every embedded resource and its size (in ``selected_resources`` tag)
- every embedded property and its value (in ``java_properties`` tag)
- every embedded string (in ``selected_internStrings`` tag)
- every embedded type (in ``selected_types`` tag)
- every embedded immutable (in ``selected_immutables`` tag)

How to Analyze a Map File Generated by a Third-Party Linker
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A ``<firmware>.map`` file is generated by the C toolchain after linking the MicroEJ Application with the BSP.
This section explains how a map file generated by GCC is structured and how to browse it. The structure is not the same on every compiler but it is often similar.

File Structure
^^^^^^^^^^^^^^

This file is composed of 5 parts:

- ``Archive member included to satisfy reference by file``. Each entry contains two lines. The first line contains the referenced archive file location and the compilation unit. The second line contains the compilation unit referencing the archive and the symbol called.	
- ``Allocating common symbols``. Each entry contains the name of a global variable, its size, and the compilation unit where it is defined.
- ``Discarded input sections``. Each entry contains the name and the size of a section that has not been embedded in the firmware.
- ``Memory Configuration``. Each entry contains the name of a memory, its address, its size, and its attributes.
- ``Linker script and memory map``. Each entry contains a line with the name and compilation unit of a section and one line per symbol defined in this section. Each of these lines contains the name, the address, and the size of the symbol.

Finding the Size of a Section or Symbol
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For example, to know the thread stacks' size, search for the ``.bss.vm.stacks.java`` section in the ``Linker script and memory map`` part. The size associated with the compilation unit is the size used by the thread stacks.

The following snippet shows that the ``.bss.vm.stacks.java`` section takes 0x800 bytes.

.. code-block::

 .bss.vm.stacks.java
                0x20014070      0x800 ..\..\..\..\..\..\..\.microej\CM4hardfp_GCC48\application\microejapp.o
                0x20014070                __icetea___6bss_6vm_6stacks_6java$$Base
                0x20014870                __icetea___6bss_6vm_6stacks_6java$$Limit

See :ref:`Core Engine Link <core_engine_link>` documentation for more information on MicroEJ sections.

How to Reduce the Image Size of an Application
----------------------------------------------

Generic coding rules may be found in the following tutorial: :ref:`improve_code_quality`.

This section provides additional coding rules and good practices to reduce the image size (ROM) of an application.

Application Resources
~~~~~~~~~~~~~~~~~~~~~

Resources such as images and fonts take a lot of memory.
For every ``.list`` file, make sure that it does not embed any unused resource. Having unused resources in the :ref:`application classpath <application.classpath.mapping>` is OK as long as they are not listed in a ``.list`` file.

Fonts
^^^^^

Default Font
""""""""""""

By default, in the platform configuration project, a so-called system font is declared inside the ``microui.xml`` file.

When generating the platform, this file is copied from the configuration project to the actual platform project. It will later be converted to binary format and linked with your MicroEJ Application, even if you use fonts different from the system font.

Therefore, you can comment the system font from the ``microui.xml`` file to reduce the ROM footprint of your MicroEJ Application if this one does not rely on the system font. Note that you will need to rebuild the platform and then the application to benefit from the footprint reduction.

See the *Display Element* section of the :ref:`section_static_init` documentation for more information on system fonts.

Character Ranges
""""""""""""""""

When creating a font, you can reduce the list of characters embedded in the font at several development stages:

- On font creation: see the *Removing Unused Characters* section of :ref:`section.tool.fontdesigner` documentation.
- On application build: see the *Fonts* section of :ref:`chapter.microej.classpath` documentation.

Pixel Transparency
""""""""""""""""""

You can also make sure that the BPP encoding used to achieve transparency for your fonts do not exceed the following values:

- The pixel depth of your display device.
- The required alpha level for a good rendering of your font in the application.

See the *Fonts* section of :ref:`chapter.microej.classpath` documentation for more information on how to achieve that.

External Storage
""""""""""""""""

To save storage on internal flash, you can access fonts from an external storage device.

See the *External Resources* section of the :ref:`section_fontgen` documentation for more information on how to achieve that.

Internationalization Data
^^^^^^^^^^^^^^^^^^^^^^^^^

Implementation
""""""""""""""

MicroEJ provides the Native Language Support (NLS for short) library to handle internationalization.

See https://github.com/MicroEJ/Example-NLS for an example of the use of the NLS library.

You can, of course, use your own internationalization library if you want. Whatever internationalization library you use, the tips below may be relevant to the footprint optimization domain.

External Storage
""""""""""""""""

The default NLS implementation fetches text resources from internal flash, but you can replace it with your own implementation to fetch them from another location.

See :ref:`section_externalresourceloader` documentation for additional information on external resources management.

Compression
"""""""""""

The default NLS implementation relies on text resources that are not compressed, but you can use your own encoding to load them from compressed resources.

Images
^^^^^^

Encoding
""""""""

If you are tight on ROM but have enough RAM and CPU power to decode PNG images on the fly, consider storing your images as PNG resources.
If you are in the opposite configuration (lots of ROM, but little RAM and CPU power), consider storing your images in raw format.

See :ref:`section_image_generator` documentation for more information on how to achieve that.

Color Depth (BPP)
"""""""""""""""""

Make sure to use images with a color depth not exceeding the one of your display to avoid the following issues:

- Waste of memory.
- Differences between the rendering on the target device and the original image resource.

External Storage
""""""""""""""""

To save storage on internal flash, the application can access the images from an external storage device.

See :ref:`section_externalresourceloader` documentation for more information on how to achieve that.

Application Code
~~~~~~~~~~~~~~~~

The following application code guidelines are recommended in order to minimize the size of the application:

- Avoid using legacy versions of packs and libraries. The latest version may be more optimized (check the changelog).
- Avoid manipulating ``String`` objects when possible. For example, prefer using integers to represent IDs. Indeed, strings take a lot of memory.
- Avoid using logging library or ``println()``, use the :ref:`trace library <event-tracing>` instead. The logging library uses strings, while the trace library is light and uses error codes.
- Avoid manipulating wrappers such as ``Integer`` and ``Long`` objects, manipulate primitive types instead. Objects take more memory and require boxing/unboxing operations.
- Avoid using service library, use singletons or ``Constants.getClass()`` instead. The service library adds extra code which doesn't add any feature to your application. It also embeds reflection methods of EDC.
- Avoid using ``List`` objects, use arrays and ``ArrayTools`` instead. Even though the collections framework is very user-friendly, the code size and the heap usage are more important than when manipulating arrays.
- Avoid using ``Map`` objects, use ``PackedMap`` instead. Packed maps provide the same features as collection maps but are much lighter.
- Avoid using ``java.util.Timer``, use ``ej.bon.Timer`` instead. EDC's timers are now deprecated.
- Use BON constants when writing debug code or optional code, such as ``if (Constants.getBoolean()) { ... }``. That way, the optional code will not be embedded if the constant is ``false``.
- Avoid using system properties, use BON constants instead. Constants checks are computed at compile time rather than at runtime. Also, manipulating properties requires to embed their name, and strings take a lot of memory.
- Avoid using synchronization. A ``synchronized`` block takes a lot of extra code size, even though it is only a few characters of code.
- Avoid overriding ``toString()`` for debugging purposes. This method will always be embedded even if it is not called explicitly.
- Avoid overriding ``equals(Object)`` and ``hashCode()``, use ``==`` operator instead if it is sufficient. Indeed, these methods take more memory and require null and type checks.
- Avoid calling ``equals()`` and ``hashCode()`` on ``Object`` references. If you do, the method will be embedded for every class that overrides the method.
- Avoid using the string concatenation operator (``+``), use ``StringBuilder`` instead. The bytecode generated by the ``+`` operator is not optimal and is bigger than when using manual ``StringBuilder`` operations.
- Avoid using ``java.util.Calendar``, use another calendar implementation instead. The calendar implementation of EDC is very heavy, even when only a few methods are used.
- Avoid creating anonymous objects (such as ``Runnable`` objects), re-use other classes instead. Indeed, these objects are treated like a whole new class, and each enclosed final variable is treated as a field of the class.
- Avoid accessing the same field multiple times in the same method, copy the value of the field into a local variable instead. Accessing fields leads to bigger code size and may induce synchronization issues.
- Avoid initializing arrays and complex objects in ``static final`` fields, use immutables instead. Indeed, initializing objects dynamically generates bytecode, which takes a lot of memory and requires execution time.

Platform Configuration
~~~~~~~~~~~~~~~~~~~~~~

The following platform configuration guidelines are recommended in order to minimize the size of the application:

- Use the latest MicroEJ architecture.
- Use tiny MEJ32 architecture. It reduces the size of the application code by ~20% but it is only possible if the size of the application code is lower than 256KB (resources excluded). See dedicated documentation: :ref:`core-tiny`.
- Disable unnecessary modules in the ``.platform`` file. For example, disable the ``Image PNG Decoder`` module if you know that the application will not load PNG images at runtime.
- Don't embed unnecessary pixel conversion algorithms. This can save up to ~8KB of code size but it requires knowing the format of the resources embedded in the application.
- Use the best optimization level for every source file (for example, ``-O3`` or ``-Os`` on GCC).
- Use an optimal compiler such as IAR rather than GCC.
- Retrieve the linker command line and check that every parameter is OK. The linker command line can be found in the project settings, and it may be printed during link. For example, if there is ``-u _printf_float`` in the parameters, you can go in the project settings and disable printf for float if you so wish.
- In the map file generated by the third-party linker, check that every embedded method is necessary. For example, hardware timers or HAL components may be initialized in the BSP but not used in the application. Also, debug methods such as SystemView may not be useful in production.

Application Configuration
~~~~~~~~~~~~~~~~~~~~~~~~~

The following application configuration guidelines are recommended in order to minimize the size of the application:

- Disable class names generation by setting the ``soar.generate.classnames`` option to ``false``. Class names are only required when using Java reflection. In such case, the name of a specific class can be explicitly embedded. Refer to :ref:`stripclassnames` section for a dedicated tutorial.
- Remove UTF-8 encoding support by setting the ``cldc.encoding.utf8.included`` option to ``false``. The default encoding (``ISO-8859-1``) is enough for most applications.
- Remove ``SecurityManager`` checks by setting the ``com.microej.library.edc.securitymanager.enabled`` option to ``false``. This feature is only useful for multi-app firmware.
- Remove ``toString()`` methods by setting the ``com.microej.library.edc.tostring.included`` option to ``false``. These methods are only useful for debugging.

For more information on how to set an option, please refer to the :ref:`setting_an_option` documentation.

.. _stripclassnames:

Stripping Class Names from an Application
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

By default, when a Java class is used, the name of the class is embedded too. A class is used when one of its methods is called, for example.
Embedding the name of every class is rarely useful and takes a lot of ROM.
This section explains how to embed only the required class names of an application.

Removing All Class Names
^^^^^^^^^^^^^^^^^^^^^^^^

In the configuration of your launcher, set the ``soar.generate.classnames`` option to ``false``.

For more information on how to set an option, please refer to the :ref:`setting_an_option` documentation.

Listing Required Class Names
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Some class names may be required by an application to work properly.
These class names must be explicitly specified in a ``*.types.list`` file.

The code of the application must be checked for all uses of the ``Class.forName()``, ``Class.getName()`` and ``Class.getSimpleName()`` methods.
Each call indicates a class name usage. Either add the class name to a ``*.types.list`` file or remove the use of the class name.

Case of ServiceLoader
"""""""""""""""""""""

A ``ServiceLoader`` is a dependency injection facility. It can be used to retrieve the implementation of a service.

The assignment between a service and its implementation is done in ``*.properties.list`` files. Both the service class name and the implementation class name must be embedded (i.e., added in a ``*.types.list`` file).

For example:

.. code-block::

	# example.properties.list
	com.example.MyService=com.example.MyServiceImpl

.. code-block::

	# example.types.list
	com.example.MyService
	com.example.MyServiceImpl

Case of Properties Loading
""""""""""""""""""""""""""

Some properties may be loaded by using the name of a class to determine the full name of the property. For example: 

.. code-block:: java

	Integer.getInteger(MyClass.class.getName() + ".myproperty");

In this case, it can be replaced with the actual string. For example:

.. code-block:: java

	Integer.getInteger("com.example.MyClass.myproperty");

Case of Logger and Other Debugging Facilities
"""""""""""""""""""""""""""""""""""""""""""""

Logging mechanisms usually display the name of the classes in traces.
It is not necessary to embed these class names. The :ref:`stack_trace_reader` can decipher the output.

How to Reduce the Runtime Size of an Application
------------------------------------------------

You can find generic coding rules in the following tutorial: :ref:`improve_code_quality`.

This section provides additional coding rules and good practices in order to reduce the runtime size (RAM) of an application.

Application Code
~~~~~~~~~~~~~~~~

The following application code guidelines are recommended in order to minimize the size of the application:

- Define fields as ``short`` or ``byte`` rather than ``int``. Integers take more memory and are not necessary when the value can not be big.
- Make sure that your widget hierarchy is as flat as possible (avoid unnecessary containers). Deep widget hierarchies take more memory and can reduce performance.
- Make sure that the size of the buffers allocated in generic components can be configured (by a parameter in the constructor or by a BON constant for example). That way, the user can select the optimal buffer size depending on his use-case and avoid wasting memory.
- Avoid using immortal arrays to call native methods, use regular arrays instead. Immortal arrays are never deallocated and they are not necessary anymore when calling a native method.
- Avoid creating multiple threads, timers, or executors, share the instances instead when possible. Each thread requires allocating dedicated VM stacks, which takes a lot of memory.
- Avoid creating mutable images (``BufferedImage`` instances) to draw in them and render them later, render graphics directly on the display instead. Mutable images require allocating a lot of memory from the images heap.

Platform Configuration
~~~~~~~~~~~~~~~~~~~~~~

The following platform configuration guidelines are recommended in order to minimize the size of the application:

- Check the size of the stack of each RTOS task. For example, 1.0KB may be enough for the MicroJVM task but it can be increased to allow deep native calls.
- Check the size of the heap allocated by the RTOS (for example, ``configTOTAL_HEAP_SIZE`` for FreeRTOS).
- Check that the size of the back buffer matches the size of the display. Use a partial buffer if the back buffer does not fit in the RAM.

Debugging Stack Overflows
^^^^^^^^^^^^^^^^^^^^^^^^^

If the size you allocate for a given RTOS task is too small, a stack overflow will occur. To be aware of stack overflows, proceed with the following steps when using FreeRTOS:

1. Enable the stack overflow check in ``FreeRTOS.h``:

.. code-block:: c

	#define configCHECK_FOR_STACK_OVERFLOW 1

2. Define the hook function in any file of your project (``main.c`` for example):

.. code-block:: c

	void vApplicationStackOverflowHook(TaskHandle_t xTask, signed char *pcTaskName) { }

3. Add a new breakpoint inside this function
4. When a stack overflow occurs, the execution will stop at this breakpoint

For further information, please refer to the `FreeRTOS documentation <https://www.freertos.org/Stacks-and-stack-overflow-checking.html>`_.

Application Configuration
~~~~~~~~~~~~~~~~~~~~~~~~~

The following application configuration guidelines are recommended in order to minimize the size of the application.

For more information on how to set an option, please refer to the :ref:`setting_an_option` documentation.

Java Heap and Immortals Heap
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

- Configure the immortals heap to be as small as possible. You can get the minimum value by calling ``Immortals.freeMemory()`` after the creation of all the immortal objects.
- Configure the Java heap to fit the needs of the application. You can get the maximum heap usage by calling ``Runtime.freeMemory()`` after ``System.gc()`` at different moments in the application's lifecycle.

Thread Stacks
^^^^^^^^^^^^^

- Configure the maximum number of threads. This number can be known accurately by counting in the code how many ``Thread`` and ``Timer`` objects may run concurrently. You can call ``Thread.getAllStackTraces()`` or ``Thread.activeCount()`` to know what threads are running at a given moment.
- Configure the number of allocated thread stack blocks. Keep the default value for the size of a block (``512``) and figure out how many blocks each thread requires. This can be done empirically by starting with a low number of blocks and increasing this number as long as the application throws a ``StackOverflowError``.
- Configure the maximum number of blocks per thread. The best choice is to set it to the number of blocks required by the most greedy thread. Another acceptable option is to set it to the same value as the total number of allocated blocks.
- Configure the maximum number of monitors. This number can be known accurately by counting the number of concurrent ``synchronized`` blocks. This can also be done empirically by starting with a low number of monitors and increasing this number as long as no exception occurs. Either way, it is recommended to set a slightly higher value than calculated.
 
VM Dump
"""""""

The ``LLMJVM_dump()`` function declared in ``LLMJVM.h`` may be called to print information on alive threads such as their current and maximum stack block usage.
This function may be called from the application by exposing it in a :ref:`native function <sni>`.

More specifically, the ``Peak java threads count`` value printed in the dump can be used to configure the maximum number of threads.
The ``max_java_stack`` and ``current_java_stack`` values printed for each thread can be used to configure the number of stack blocks.

MicroUI Images Heap
^^^^^^^^^^^^^^^^^^^

- Configure the images heap to be as small as possible. You can compute the optimal size empirically. It can also be calculated accurately by adding the size of every image that may be stored in the images heap at a given moment. One way of doing this is to inspect every occurrence of ``new BufferedImage()`` and ``ResourceImage.loadImage()``.
