==============
MicroEJ Linker
==============


Overview
========

MicroEJ Linker is a standard linker that is compliant with the
Executable and Linkable File format (ELF).

MicroEJ Linker takes one or several relocatable binary files and
generates an image representation using a description file. The process
of extracting binary code, positioning blocks and resolving symbols is
called linking.

Relocatable object files are generated by SOAR and third-party
compilers. An archive file is a container of Relocatable object files.

The description file is called a Linker Specific Configuration file
(lsc). It describes what shall be embedded, and how those things shall
be organized in the program image. The linker outputs :

-  An ELF executable file that contains the image and potential debug
   sections. This file can be directly used by debuggers or programming
   tools. It may also be converted into a another format (Intel\* hex,
   Motorola\* s19, rawBinary, etc.) using external tools, such as
   standard GNU binutils toolchain (objcopy, objdump, etc.).

-  A map file, in XML format, which can be viewed as a database of what
   has been embedded and resolved by the linker. It can be easily
   processed to get a sort of all sizes, call graphs, statistics, etc.

-  The linker is composed with one or more library loaders, according to
   the platform's configuration.


ELF Overview
============

An ELF relocatable file is split into several sections:

-  allocation sections representing a part of the program

-  control sections describing the binary sections (relocation sections,
   symbol tables, debug sections, etc.)

An allocation section can hold some image binary bytes (assembler
instructions and raw data) or can refer to an interval of memory which
makes sense only at runtime (statics, main stack, heap, etc.). An
allocation section is an atomic block and cannot be split. A section has
a name that by convention, represents the kind of data it holds. For
example, ``.text`` sections hold binary instructions, ``.bss`` sections
hold read-write static data, ``.rodata`` hold read-only data, and
``.data`` holds read-write data (initialized static data). The name is
used in the .lsc file to organize sections.

A symbol is an entity made of a name and a value. A symbol may be
absolute (link-time constant) or relative to a section: Its value is
unknown until MicroEJ Linker has assigned a definitive position to the
target section. A symbol can be local to the relocatable file or global
to the system. All global symbol names should be unique in the system
(the name is the key that connects an unresolved symbol reference to a
symbol definition). A section may need the value of symbols to be fully
resolved: the address of a function called, address of a static
variable, etc.


Linking Process
===============

The linking process can be divided into three main steps:

1. Symbols and sections resolution. Starting from root symbols and root
   sections, the linker embeds all sections targeted by symbols and all
   symbols referred by sections. This process is transitive while new
   symbols and/or sections are found. At the end of this step, the
   linker may stop and output errors (unresolved symbols, duplicate
   symbols, unknown or bad input libraries, etc.)

2. Memory positioning. Sections are laid out in memory ranges according
   to memory layout constraints described by the lsc file. Relocations
   are performed (in other words, symbol values are resolved and section
   contents are modified). At the end of this step, the linker may stop
   and output errors (it could not resolve constraints, such as not
   enough memory, etc.)

3. An output ELF executable file and map file are generated.

A partial map file may be generated at the end of step 2. It provides
useful information to understand why the link phase failed. Symbol
resolution is the process of connecting a global symbol name to its
definition, found in one of the linker input units. The order the units
are passed to the linker may have an impact on symbol resolution. The
rules are :

-  Relocatable object files are loaded without order. Two global symbols
   defined with the same name result in an unrecoverable linker error.

-  Archive files are loaded on demand. When a global symbol must be
   resolved, the linker inspects each archive unit in the order it was
   passed to the linker. When an archive contains a relocatable object
   file that declares the symbol, the object file is extracted and
   loaded. Then the first rule is applied. It is recommended that you
   group object files in archives as much as possible, in order to
   improve load performances. Moreover, archive files are the only way
   to tie with relocatable object files that share the same symbols
   definitions.

-  A symbol name is resolved to a weak symbol if - and only if - no
   global symbol is found with the same name.


Linker Specific Configuration File Specification
================================================

Description
-----------

A Linker Specific Configuration (Lsc) file contains directives to link
input library units. An lsc file is written in an XML dialect, and its
contents can be divided into two principal categories:

-  Symbols and sections definitions.

-  Memory layout definitions.

<?xml version="1.0" encoding="UTF-8"?> <!-- An example of linker
specific configuration file --> <lsc name="MyAppInFlash"> <include
name="subfile.lscf"/> <!-- Define symbols with arithmetical and logical
expressions --> <defSymbol name="FlashStart" value="0"/> <defSymbol
name="FlashSize" value="0x10000"/> <defSymbol name="FlashEnd"
value="FlashStart+FlashSize-1"/> <!-- Define FLASH memory interval -->
<defSection name="FLASH" start="FlashStart" size="FlashSize"/> <!-- Some
memory layout directives --> <memoryLayout ranges ="FLASH"> <sectionRef
name ="*.text"/> <sectionRef name ="*.data"/> </memoryLayout> </lsc>

File Fragments
--------------

An lsc file can be physically divided into multiple lsc files, which are
called lsc fragments. Lsc fragments may be loaded directly from the
linker path option, or indirectly using the include tag in an lsc file.

Lsc fragments start with the root tag ``lscFragment``. By convention the
lsc fragments file extension is ``.lscf``. From here to the end of the
document, the expression "the lsc file" denotes the result of the union
of all loaded (directly and indirectly loaded) lsc fragments files.

Symbols and Sections
--------------------

A new symbol is defined using ``defSymbol`` tag. A symbol has a name and
an expression value. All symbols defined in the lsc file are global
symbols.

A new section is defined using the ``defSection`` tag. A section may be
used to define a memory interval, or define a chunk of the final image
with the description of the contents of the section.


Memory Layout
=============

A memory layout contains an ordered set of statements describing what
shall be embedded. Memory positioning can be viewed as moving a cursor
into intervals, appending referenced sections in the order they appear.
A symbol can be defined as a "floating" item: Its value is the value of
the cursor when the symbol definition is encountered. In
`figure_title <#linker-memorylayout-example>`__, the memory layout sets
the ``FLASH`` section. First, all sections named ``.text`` are embedded.
The matching sections are appended in a undefined order. To reference a
specific section, the section shall have a unique name (for example a
reset vector is commonly called ``.reset`` or ``.vector``, etc.). Then,
the floating symbol ``dataStart`` is set to the absolute address of the
virtual cursor right after embedded ``.text`` sections. Finally all
sections named ``.data`` are embedded.

A memory layout can be relocated to a memory interval. The positioning
works in parallel with the layout ranges, as if there were two cursors.
The address of the section (used to resolve symbols) is the address in
the relocated interval. Floating symbols can refer either to the layout
cursor (by default), or to the relocated cursor, using the
``relocation`` attribute. A relocation layout is typically used to embed
data in a program image that will be used at runtime in a read-write
memory. Assuming the program image is programmed in a read only memory,
one of the first jobs at runtime, before starting the main program, is
to copy the data from read-only memory to ``RAM``, because the symbols
targeting the data have been resolved with the address of the sections
in the relocated space. To perform the copy, the program needs both the
start address in ``FLASH`` where the data has been put, and the start
address in ``RAM`` where the data shall be copied.

<memoryLayout ranges="FLASH" relocation="RAM" image="true"> <defSymbol
name="DataFlashStart" value="."/> <defSymbol name="DataRamStart" value="
." relocation="true"/> <sectionRef name=".data"/> <defSymbol
name="DataFlashLimit" value="."/> </memoryLayout>

Note: the symbol ``DataRamStart`` is defined to the start address where
``.data`` sections will be inserted in ``RAM`` memory.
